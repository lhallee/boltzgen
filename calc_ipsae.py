"""
calc_ipsae.py - Calculate ipSAE scores for BoltzGen protein designs

================================================================================
OVERVIEW
================================================================================

This script calculates ipSAE (interface predicted Structural Alignment Error)
scores for protein-protein interactions in designs generated by the BoltzGen
pipeline. ipSAE is a confidence metric where LOWER scores indicate BETTER
predicted binding interactions.

Reference: https://www.biorxiv.org/content/10.1101/2025.02.10.637595v1

================================================================================
HOW IT WORKS
================================================================================

1. DIRECTORY STRUCTURE
   The script expects BoltzGen's standard output structure:
   
   <output_dir>/
   ├── final_ranked_designs/
   │   ├── final_N_designs/           # N = number of designs (e.g., 30)
   │   │   ├── rank0_design.cif       # Refolded structure files
   │   │   ├── rank1_design.cif
   │   │   └── pae/                   # PAE prediction data
   │   │       ├── rank0_design.npz
   │   │       └── rank1_design.npz
   │   └── final_designs_metrics_N.csv
   └── designs_ranked_by_ipsae.fasta  # Output (auto-generated)

2. HANDLING MULTIPLE PAE SAMPLES
   BoltzGen runs multiple folding seeds per design, producing PAE matrices
   with shape (num_samples, N, N) where num_samples is typically 5. This
   script evaluates ipSAE on EACH sample independently and returns the
   BEST (lowest) score across all samples.
   
   This is important because different folding seeds can produce varying
   confidence estimates, and taking the best sample gives the most
   favorable assessment of each design's binding potential.

3. OUTPUT
   - FASTA file: Sequences ranked by ipSAE (best first)
   - CSV file: Summary with ipSAE scores and metadata

================================================================================
USAGE
================================================================================

# Basic usage - just provide the output directory from BoltzGen
python calc_ipsae.py <output_dir>

# Example with actual path
python calc_ipsae.py test

# Custom cutoffs (default: 15 Angstroms for both)
python calc_ipsae.py test --pae_cutoff 12 --dist_cutoff 12

================================================================================
"""

import argparse
import pandas as pd
import subprocess
import sys
import tempfile
import shutil
import numpy as np
from pathlib import Path


def run_ipsae_on_single_pae(
    pae_file_path: str,
    structure_file_path: str,
    pae_cutoff: float,
    dist_cutoff: float,
) -> float:
    """
    Run ipsae.py on a single 2D PAE matrix and return the ipSAE score.
    
    Returns:
        float: The ipSAE score (lower is better), or inf on failure
    """
    # Try py (Windows) first, then python
    for python_cmd in ["py", "python"]:
        try:
            command = [
                python_cmd,
                "ipsae.py",
                pae_file_path,
                structure_file_path,
                str(pae_cutoff),
                str(dist_cutoff),
            ]
            result = subprocess.run(command, capture_output=True, text=True)
            if result.returncode == 0:
                break
        except Exception:
            continue

    # Read results from the output file (ipsae.py writes next to CIF)
    results_path = structure_file_path.replace('.cif', f'_{int(pae_cutoff)}_{int(dist_cutoff)}.txt')
    
    try:
        df = pd.read_csv(results_path)
        results = {}

        for _, row in df[df.Type == "max"].iterrows():
            chainpair = f"{row['Chn1']}-{row['Chn2']}"
            results[chainpair] = {"max": {col: row[col] for col in df.columns[5:-1]}}
            
            mask = (df['Chn1'] == row['Chn1']) & (df['Chn2'] == row['Chn2']) & (df['Type'] != "max")
            min_vals = df[mask][df.columns[5:-1]].min()
            results[chainpair]["min"] = min_vals.to_dict()

        if 'A-C' in results: # we set target to chain A and design to chain C for boltzgen
            return results['A-C']['min']['ipSAE']
        else:
            first_pair = list(results.keys())[0]
            return results[first_pair]['min']['ipSAE']
        
    except Exception:
        return float('inf')


def calculate_ipsae(
    pae_file_path: str,
    structure_file_path: str,
    pae_cutoff: float = 15.0,
    dist_cutoff: float = 15.0,
) -> float:
    """
    Calculate ipSAE score for a protein-protein interaction.
    
    BoltzGen produces PAE matrices with shape (num_samples, N, N) from multiple
    folding seeds. This function evaluates each sample and returns the best
    (lowest) ipSAE score.

    Args:
        pae_file_path: Path to the PAE file (.npz)
        structure_file_path: Path to the structure file (.cif)
        pae_cutoff: PAE threshold in Angstroms (default: 15.0)
        dist_cutoff: Distance threshold in Angstroms (default: 15.0)

    Returns:
        float: The best ipSAE score across all samples (lower is better)
    """
    # Load the npz file
    try:
        data = np.load(pae_file_path)
        pae_matrix = data['pae']
    except Exception as e:
        print(f"    Error loading PAE file: {e}")
        return float('inf')
    
    # Check if PAE is 3D (boltzgen format: num_samples x N x N)
    if pae_matrix.ndim == 3:
        num_samples = pae_matrix.shape[0]
        print(f"    Evaluating {num_samples} folding samples...")
        
        best_ipsae = float('inf')
        best_sample = -1
        
        # Create temp directory for sample-specific files
        temp_dir = Path(tempfile.mkdtemp())
        
        try:
            for sample_idx in range(num_samples):
                # Extract this sample's 2D PAE matrix
                sample_pae = pae_matrix[sample_idx]
                
                # Temp file name MUST contain "pae" for ipsae.py's internal file lookup
                temp_npz_path = temp_dir / f"pae_sample_{sample_idx}.npz"
                np.savez_compressed(temp_npz_path, pae=sample_pae)
                
                # Copy CIF to temp directory (ipsae.py writes output next to CIF)
                temp_cif_path = temp_dir / f"sample_{sample_idx}.cif"
                shutil.copy2(structure_file_path, temp_cif_path)
                
                # Run ipsae.py on this sample
                ipsae_score = run_ipsae_on_single_pae(
                    str(temp_npz_path),
                    str(temp_cif_path),
                    pae_cutoff,
                    dist_cutoff
                )
                
                if ipsae_score < best_ipsae:
                    best_ipsae = ipsae_score
                    best_sample = sample_idx
            
            if best_sample >= 0:
                print(f"    Best: {best_ipsae:.4f} (sample {best_sample + 1}/{num_samples})")
            
            return best_ipsae
            
        finally:
            shutil.rmtree(temp_dir, ignore_errors=True)
    
    else:
        # 2D PAE matrix - run directly (standard boltz1 format)
        return run_ipsae_on_single_pae(
            pae_file_path,
            structure_file_path,
            pae_cutoff,
            dist_cutoff
        )


def write_fasta(designs: list, output_path: str):
    """Write designs to a FASTA file with ipSAE annotations."""
    with open(output_path, 'w') as f:
        for design in designs:
            header = f">{design['id']}|ipSAE={design['ipsae']:.4f}|rank={design['ipsae_rank']}"
            f.write(f"{header}\n")
            seq = design['sequence']
            for i in range(0, len(seq), 80):
                f.write(f"{seq[i:i+80]}\n")


def process_output_dir(
    output_dir: str,
    pae_cutoff: float = 15.0,
    dist_cutoff: float = 15.0,
):
    """
    Process BoltzGen output directory and calculate ipSAE scores for all designs.

    Args:
        output_dir: Path to BoltzGen output directory
        pae_cutoff: PAE threshold in Angstroms
        dist_cutoff: Distance threshold in Angstroms
    """
    output_dir = Path(output_dir)
    
    # Auto-derive paths from output directory
    final_designs_dir = output_dir / "final_ranked_designs"
    output_fasta = output_dir / "designs_ranked_by_ipsae.fasta"
    
    if not final_designs_dir.exists():
        print(f"Error: Could not find final_ranked_designs in {output_dir}")
        print(f"Expected: {final_designs_dir}")
        sys.exit(1)
    
    # Find the final designs subdirectory (final_N_designs)
    final_subdir = None
    for subdir in final_designs_dir.iterdir():
        if subdir.is_dir() and subdir.name.startswith("final_") and subdir.name.endswith("_designs"):
            final_subdir = subdir
            break
    
    if final_subdir is None:
        print(f"Error: Could not find final_*_designs subdirectory in {final_designs_dir}")
        sys.exit(1)
    
    print(f"Processing: {final_subdir}")
    
    # Find metrics CSV
    metrics_csvs = list(final_designs_dir.glob("final_designs_metrics_*.csv"))
    if not metrics_csvs:
        metrics_csvs = list(final_designs_dir.glob("all_designs_metrics.csv"))
    
    if not metrics_csvs:
        print(f"Error: Could not find metrics CSV in {final_designs_dir}")
        sys.exit(1)
    
    metrics_csv = metrics_csvs[0]
    print(f"Metrics: {metrics_csv.name}")
    
    df_metrics = pd.read_csv(metrics_csv)
    
    # Build filename to sequence mapping
    filename_to_seq = {}
    filename_to_chain_seq = {}
    for _, row in df_metrics.iterrows():
        filename_to_seq[row['file_name']] = row['designed_sequence']
        filename_to_chain_seq[row['file_name']] = row['designed_chain_sequence']
    
    # Find CIF and PAE files
    cif_files = sorted(final_subdir.glob("*.cif"))
    pae_dir = final_subdir / "pae"
    
    if not pae_dir.exists():
        print(f"Error: PAE directory not found at {pae_dir}")
        print("Make sure the pipeline completed successfully.")
        sys.exit(1)
    
    print(f"Found {len(cif_files)} designs")
    print(f"Cutoffs: PAE={pae_cutoff}Å, Distance={dist_cutoff}Å")
    print("-" * 50)
    
    designs = []
    
    for cif_path in cif_files:
        cif_name = cif_path.name
        
        # Extract original filename (remove rank prefix: rank00_name.cif -> name.cif)
        parts = cif_name.split('_', 1)
        original_name = parts[1] if len(parts) > 1 else cif_name
        
        # Find corresponding PAE file
        npz_path = pae_dir / cif_name.replace('.cif', '.npz')
        
        if not npz_path.exists():
            print(f"  {cif_name}: PAE file missing, skipping")
            continue
        
        # Get sequence
        sequence = filename_to_seq.get(original_name, "")
        chain_sequence = filename_to_chain_seq.get(original_name, "")
        
        if not sequence and not chain_sequence:
            print(f"  {cif_name}: Sequence not found, skipping")
            continue
        
        # Calculate ipSAE
        print(f"  {cif_name}")
        ipsae = calculate_ipsae(str(npz_path), str(cif_path), pae_cutoff, dist_cutoff)
        
        designs.append({
            'id': cif_path.stem,
            'original_name': original_name.replace('.cif', ''),
            'sequence': chain_sequence if chain_sequence else sequence,
            'designed_sequence': sequence,
            'ipsae': ipsae,
            'cif_path': str(cif_path),
        })
    
    if not designs:
        print("Error: No designs were processed successfully")
        sys.exit(1)
    
    # Sort by ipSAE (lower is better)
    designs.sort(key=lambda x: x['ipsae'])
    
    # Add ranks
    for i, design in enumerate(designs):
        design['ipsae_rank'] = i + 1
    
    # Write FASTA
    write_fasta(designs, str(output_fasta))
    
    # Write summary CSV
    summary_csv = output_dir / "designs_ranked_by_ipsae_summary.csv"
    summary_df = pd.DataFrame([{
        'ipsae_rank': d['ipsae_rank'],
        'id': d['id'],
        'original_name': d['original_name'],
        'ipsae': d['ipsae'],
        'designed_sequence': d['designed_sequence'],
        'chain_sequence': d['sequence'],
    } for d in designs])
    summary_df.to_csv(summary_csv, index=False)
    
    # Print summary
    print("\n" + "=" * 60)
    print("ipSAE RANKING (lower is better)")
    print("=" * 60)
    print(f"{'Rank':<6} {'ID':<40} {'ipSAE':<12}")
    print("-" * 60)
    for d in designs[:10]:
        print(f"{d['ipsae_rank']:<6} {d['id']:<40} {d['ipsae']:<12.4f}")
    if len(designs) > 10:
        print(f"... and {len(designs) - 10} more designs")
    print("=" * 60)
    print(f"\nOutputs:")
    print(f"  FASTA: {output_fasta}")
    print(f"  CSV:   {summary_csv}")
    
    return designs


def main():
    parser = argparse.ArgumentParser(
        description="Calculate ipSAE scores for BoltzGen protein designs",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument(
        "output_dir",
        type=str,
        nargs='?',
        default=None,
        help="BoltzGen output directory (contains final_ranked_designs/)"
    )
    parser.add_argument(
        "--pae_cutoff",
        type=float,
        default=15.0,
        help="PAE cutoff in Angstroms (default: 15.0)"
    )
    parser.add_argument(
        "--dist_cutoff",
        type=float,
        default=15.0,
        help="Distance cutoff in Angstroms (default: 15.0)"
    )
    
    args = parser.parse_args()
    
    # Auto-detect output directory if not specified
    if args.output_dir is None:
        candidates = ["output", "test", "."]
        for candidate in candidates:
            if (Path(candidate) / "final_ranked_designs").exists():
                args.output_dir = candidate
                print(f"Auto-detected output directory: {candidate}")
                break
        
        if args.output_dir is None:
            print("Error: Could not find output directory with final_ranked_designs/")
            print("Please specify the output directory as an argument.")
            parser.print_help()
            sys.exit(1)
    
    process_output_dir(
        args.output_dir,
        args.pae_cutoff,
        args.dist_cutoff,
    )


if __name__ == "__main__":
    main()
